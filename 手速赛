thought from duoxida

A.
两个人像扫描线一样向上走，【事实上也就是扫描线。。
想想假如我们从时间0开始， 那么每个线段就 <=> [max(li,ti), ri]。
然后就是求这个线段并。。。
等一下。。。好像询问有点多。。。
没关系，假如询问是那啥 q 吧。。
那么每个线段 <=> [max(li,ti-q), ri], 嘛。。这样一来怎么求并呢。。
嘛， 假如有两个线段是 [1,5](t=3), [3,7](t=2)
你就将它转化成[1,2](t=3),[3,5](t=2),[6,7](t=2)。。。
啊。这样一来，世界就美好了，在也没有线段相交了。
然后怎么做呢？排两个序。【ti-li排一个，ti-ri排一个
之后题目很有爱的给出的q都是递增的，扫一遍就知道哪些区间完整哪些不完整。

B.
这个题。首先要变成47的形式。
想象一下 444 ~ 777的乘法。。
可以转化为 4|44 ~ 4|77, 4|77 * 7|44, 7|44 ~ 7|77
如果我们只看后面两位就转化成了新的子问题。比如444 ~ 477
可以变成 400+44 ~ 400+77 = 44~77 + (2^2-1)*400^2 + 400*(2*sigma 44~77 - 44 - 77)
这题大概比较麻烦，理清楚代码也不长。
给个参考：
用 a[1] = 4 + 7 , a[2] = 44 + 47 + 74 + 77 ...
用 b[1] = 4 * 7 , b[2] = 44*47 + 47*74 + 74*77
那么 b[n] = 11*10^n * (2*a[n-1]-44..4 - 77..7) + (2^(n-1)-1)*11*10^2n + 2*b[n-1]

C.
这题典型的树形dp
做的方式很多，我就不来局限思路了。
给个参考就是。。用cs[u]表示u为根的子树中不包括u的所有路径数
同时用 C2(n) 表示 n*(n-1)/2
那么 ans = sigma{ (C2(sz[u]) - cs[u] ) * C2(n-sz[u]) }

D.
这个题首先把所有两点间的距离求出来。如果和别的线段相交就是正无穷。
然后floyd一下。
这里有一个fact， 最小路径覆盖 = n - 最大匹配。
最小路径覆盖要小于k个士兵
所以 n - hungry() <= k
二分一下food建边就出来了。【注意只能从编号小顶点往编号大顶点建边

E.
所谓的change都是在某两个点中垂线上才会发生，所以枚举中垂线，
在起点终点上数一数就出来了。【当然你要判断这个中垂线是不是能使signal改变


PS： 以上思路仅供参考，不一定是最好的。。。
